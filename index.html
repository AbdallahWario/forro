<html>
	<head>
		<script>
const PUBKEY_PFX  = 'pgp.publickey';
const STATE = {
	DEV: 1 << 0,
	PANIC: 1 << 1,
	RTS:  1 << 2,
	SEND_ERROR: 1 << 3,
	SETTINGS: 1 << 4,
	REMOTE_KEY: 1 << 5,
	LOCAL_KEY: 1 << 6,
	LOCAL_KEY_DECRYPTED: 1 << 7,
	LOCAL_KEY_IDENTIFIED: 1 << 8,
	LOCAL_KEY_GENERATE: 1 << 9,
	PASSPHRASE_STORED: 1 << 9,
};
const STATE_KEYS = Object.keys(STATE);

let g_passphrase = undefined;
let g_passphrase_use = true;
let g_passphrase_time = 0;
let g_remote_key = undefined;
let g_local_key = undefined;
let g_remote_key_id = '(none)';
let g_remote_key_name = '?';
let g_local_key_id = '(none)';
let g_local_key_name = '?';
let g_local_key_identified = false;
let g_data_endpoint = window.location.href;
let g_state = 1;
let g_counter = undefined;
		</script>
		<script src="node_modules/openpgp/dist/openpgp.min.js"></script>
		<script src="node_modules/jssha/dist/sha256.js"></script>
		<script defer src="node_modules/alpinejs/dist/cdn.min.js"></script>
		<script src="key.js"></script>
		<script src="name.js"></script>
		<script>

			// Thanks to:
			// https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
			function buf2hex(buffer) { // buffer is an ArrayBuffer
				  return [...new Uint8Array(buffer)]
				      .map(x => x.toString(16).padStart(2, '0'))
				      .join('');
			}
		
			function msg_identifier() {
				return 'msg' + g_counter;
			}

			function debugState(state) {
				let s = '';
				for (let i = 0; i < STATE_KEYS.length; i++) {
					const v = 1 << i;
					if (checkState(state, v)) {
						const k = STATE_KEYS[i];
						if (s.length > 0) {
							s += ',';
						}
						s += k;
					}
				}
				return s;
			};
			
			function checkState(bit_check, bit_field) {
				if (bit_field != 0 && !bit_field) {
					bit_field = g_state;
				}
				return (bit_check & bit_field) > 0;
			};

			async function loadSettings() {
				let rs = await fetch(window.location.href + '/settings.json', {
					method: 'GET',
				});
				if (!rs.ok) {
					stateChange('could not load settings');
					throw('could not load settings');
				}
				return await rs.json();
			}

			function getEffectiveName(k) {
				let kl = k.toPacketList();
				let klf = kl.filterByTag(openpgp.enums.packet.userID);
				if (klf.length > 1) {
					stateChange('local key has been identified', STATE["LOCAL_KEY_IDENTIFIED"]);
					g_local_key_identified = true;
				}
				return klf[klf.length-1].name;
			}
			
			async function unlockLocalKey(pwd) {
				let state = [];
				try {
					g_local_key = await getKey(pwd);
					state.push(STATE['LOCAL_KEY']);
				} catch(e) {
					console.error(e);
					stateChange('could not unlock key (passphrase: ' + pwd !== undefined + ')');
					return false;
				}
				const decrypted = g_local_key.isDecrypted()
				if (decrypted) {
					state.push(STATE['LOCAL_KEY_DECRYPTED']);
				}

				stateChange('found key ' + g_local_key.getKeyID().toHex() + ' (decrypted: ' + decrypted + ')', state);
				return decrypted;
			}

			async function applyLocalKey() {
				g_local_key_id = g_local_key.getKeyID().toHex();
				g_local_key_name = getEffectiveName(g_local_key);
				
				stateChange('load counter');
				let c = localStorage.getItem('msg-count');
				if (c == null) {
					g_counter = 0;
				} else {
					g_counter = parseInt(c);
				}
				stateChange('ready to send', STATE['RTS']);
			}

			async function setUp() {
				let settings = await loadSettings();
				if (settings.data_endpoint !== undefined) {
					g_data_endpoint = settings.data_endpoint;
					stateChange('updated data endpoint to ' + settings.data_endpoint);
				}

				stateChange('loaded settings', STATE['SETTINGS']);
				let r = await fetch(settings.remote_pubkey_url);
				let remote_key_src = await r.text();
				let remote_key = await openpgp.readKey({
					armoredKey: remote_key_src,
				});
				g_remote_key = remote_key;
				g_remote_key_id = g_remote_key.getKeyID().toHex();
				g_remote_key.getPrimaryUser().then((v) => {
					g_remote_key_name = v.user.userID.name;
					stateChange('loaded remote encryption key', STATE['REMOTE_KEY']);
				});
			}

			async function stateChange(s, set_states, rst_states) {
				if (!set_states) {
					set_states = [];
				} else if (!Array.isArray(set_states)) {
					set_states = [set_states];
				}
				if (!rst_states) {
					rst_states = [];
				} else if (!Array.isArray(rst_states)) {
					rst_states = [rst_states];
				}
				let new_state = g_state;
				for (let i = 0; i < set_states.length; i++) {
					let state = parseInt(set_states[i]);
					new_state |= state;
				}
				for (let i = 0; i < rst_states.length; i++) {
					let state = parseInt(set_states[i]);
					new_state = new_state & (0xffffffff & ~rst_states[i]);
				}
				let k_remote_str = '';
				let k_local_str = '';
				if (g_remote_key !== undefined) {
					k_remote_str = g_remote_key_id + ' (' + g_remote_key_name + ')';
				}
				if (g_local_key !== undefined) {
					k_local_str = g_local_key_id + ' (' + g_local_key_name + ')';
				}

				g_state = new_state;

				const ev = new CustomEvent('messagestatechange', {
					bubbles: true,
					cancelable: false,
					composed: true,
					
					detail: {
						s: s,
						c: g_counter,
						kr: k_remote_str,
						kl: k_local_str,
						state: new_state,
					},
				});
				window.dispatchEvent(ev);
			}

			async function tryDispatch(s, name, email) {
				stateChange('starting dispatch', undefined, [STATE['RTS'], STATE['SEND_ERROR']]);
				let r = undefined;
				try {
					r = await dispatch(s, name, email)
				} catch(e) {
					console.error(e);
					stateChange('send fail: ' + e, STATE['SEND_ERROR']);
					r = 'failed';
					// on fail the msg count will be wrong in error message
				}
				stateChange('ready to send again', STATE['RTS']);
				return r;
			}

			function getPassphrase() {
				return g_passphrase;
			}

			async function tryIdentify(name, email) {
				if (g_local_key_identified) {
					return false;
				}
				g_local_key = await identify(g_local_key, name, email, getPassphrase());
				g_local_key_name = getEffectiveName(g_local_key);
				await stateChange('apply name change: ' + g_local_key_name);
				console.debug('updated public key', g_local_key.toPublic().armor());
				g_local_key_identified = true;
			}

			async function dispatch(s, name, email) {
				if (name) {
					if (!validateEmail(email)) {
						throw 'invalid email: ' + email;
					}
					await tryIdentify(name, email);
				}

				let pfx = msg_identifier();

				stateChange('sign and encrypt message ' + g_counter);
				const sha_raw = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
				sha_raw.update(s);
				const digest = sha_raw.getHash("HEX");
				console.debug('digest for unencrypted message:', digest);
	
				const rcpt_public = await generatePointer(g_local_key, PUBKEY_PFX + g_remote_key.getFingerprint());
				console.debug('digest for pubkey:', rcpt_public);

				const payload = "msg id: " + pfx + "\npubkey link: " + g_data_endpoint + "/" + rcpt_public + "\n\n" + s;
				const msg = await openpgp.createMessage({
					text: payload,
				});
				let msg_sig_inner = await openpgp.sign({
					signingKeys: g_local_key,
					message: msg,
					format: 'binary',
				});

				const msg_sig = await openpgp.createMessage({
					binary: msg_sig_inner,
				});

				const enc = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_sig,
				});

				let envelope = await openpgp.createMessage({
					binary: enc,
				});
				
				stateChange('sign and encode message request ' + g_counter);
				const auth = await generateAuth(g_local_key, envelope);

				const rcpt = await generatePointer(g_local_key, pfx);
				console.debug('digest for encrypted message:', rcpt);

				stateChange('send message ' + g_counter);
				let res = await fetch(g_data_endpoint + '/' + pfx, {
					method: 'PUT',
					body: enc,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + auth,
					}
				});
				
				rcpt_remote = await res.text();
				if (rcpt_remote.toLowerCase() != rcpt.toLowerCase()) {
					throw "mutable ref mismatch between local and server; " + rcpt + " != " + rcpt_remote;
				}
				g_counter += 1;
				stateChange('update local state, next message is: ' + g_counter);
				localStorage.setItem('msg-count', g_counter);

				stateChange('sign and encode public key store request');
				const pubkey_bin = g_local_key.toPublic().write();
				const msg_pubkey = await openpgp.createMessage({
					binary: pubkey_bin,
				});

				const enc_pubkey = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_pubkey,
				});
				let envelope_pubkey = await openpgp.createMessage({
					binary: enc_pubkey,
				});

				const pubkey_auth = await generateAuth(g_local_key, envelope_pubkey);

				stateChange('send publickey ' + g_local_key_id);
				res = await fetch(g_data_endpoint + '/' + PUBKEY_PFX + g_remote_key.getFingerprint(), {
					method: 'PUT',
					body: enc_pubkey,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + pubkey_auth,
					}
				});


				stateChange('ready to send next message');
				return rcpt;
			};
		
			async function createLocalKey(pwd) {
				stateChange('generate new local signing key', STATE["LOCAL_KEY_GENERATE"]);
				const uid = {
					name: generateName(),
					email: 'foo@devnull.holbrook.no',
				};
				g_local_key = await generatePGPKey(pwd, uid);
				stateChange('new local signing key named ' + uid.name, STATE["LOCAL_KEY"], STATE["LOCAL_KEY_GENERATE"]);
			}

			async function setPwd(pwd) {
				if (!pwd) {
					pwd = undefined;
				}
				if (pwd === undefined) {
					if (g_local_key === undefined) {
						g_passphrase_use = false;
						await createLocalKey();
					}
				} else if (g_local_key === undefined) {
					await createLocalKey(pwd);
				}
				let r = false;
				console.log('rrr', r);
				r = await unlockLocalKey(pwd);
				if (r) {
					applyLocalKey();
				}
				g_passphrase = pwd;
				g_passphrase_time = Date.now();
				return r;
			}

			function purgeLocalKey() {
				key_id = g_local_key_id;
				localStorage.removeItem('pgp-key');
				localStorage.removeItem('msg-count');
				g_local_key = undefined;
				g_local_key_id = undefined;
				g_local_key_identified = false;
				g_counter = 0;
				g_passphrase = undefined;
				g_passphrase_time = new Date(0);
				const purgeResetStates =  [
					STATE["LOCAL_KEY"],
					STATE["LOCAL_KEY_DECRYPTED"],
					STATE["LOCAL_KEY_IDENTIFIED"],
					STATE["PASSPHRASE_STORED"],
					STATE["RTS"],
					STATE["SEND_ERROR"],
				];
				stateChange('deleted local key ' + key_id, undefined, purgeResetStates);
				return true;
			}

			window.addEventListener('messagestatechange', (v) => {
				console.debug('message state change:', v.detail.state, debugState(v.detail.state), v.detail.s);
			});



		</script>
	</head>

	<body x-data="{
		have_passphrase: false,
		key: '',
		rkey: '',
		key_armor: undefined,
		rkey_armor: undefined,
		defaultname: true,
		identify: false,
		realname: '',
		realemail: '',
		message_status: '',
		message_count: g_counter,
		passphrase_status: 'please create key',
		last_state: 0,
		last_state_string: '',
		dev: false,

		get haveSettings() {
			return this.last_state & STATE['SETTINGS'] > 0;
		},

		get isDev() {
			return this.last_state & STATE['DEV'] > 0;
		},

		get lastState() {
			return debugState(this.last_state);
		},

		}"

		x-on:messagestatechange.window="last_state = $event.detail.state; last_state_string = debugState(last_state);"

		x-init="
		      have_passphrase = await unlockLocalKey();
		      if (key.length > 0) {
				if (have_passphrase) {
					applyLocalKey();
				} else {
					passphrase_status = 'please unlock key';
				}
			}"
>
		<h1><a href="https://git.defalsify.org/cgit/forro">forro v0.0.4 (GPLv3)</a></h1>
		<p x-show='isDev'>state <span x-text='lastState'></span></p>	
		<div x-data="{
			passphrase_cache: '',
		     }"
		     
		      

			x-show='!have_passphrase'>
			<input name="pwd" type="password" x-model='passphrase_cache' x-bind:placeholder='passphrase_status' />
			<button x-data="{
				go_label: 'go',
				}"
				x-text='go_label'
				@click='have_passphrase = await setPwd(passphrase_cache); if (!have_passphrase) { passphrase_status = "wrong passphrase";  go_label = "go again"; passphrase_cache = ""; };' ></button>
			<button x-show='!key' @click='have_passphrase = true; await setPwd();' >without passphrase</button>
		</div>
		<div x-show='have_passphrase' x-init="await setUp();" x-data="{
			rcpt: '',
			content: '',
			
			}">
			<dl>
				<dt>Status:</dt>
				<dd x-text="message_status" x-on:messagestatechange.window="message_status = $event.detail.s; message_count = $event.detail.c; key = $event.detail.kl; rkey = $event.detail.kr; if (key_armor === undefined && g_local_key !== undefined) { key_armor = g_local_key.armor(); }; if (rkey_armor === undefined && g_remote_key !== undefined) { rkey_armor = g_remote_key.armor(); }; defaultname = !g_local_key_identified;"></dd>

				<dt>Your identity:</dt>
				<dd><a x-text="key" x-bind:href="'data:text/plain;charset=utf-8,' + key_armor" download="privatekey.asc"></a></dd>
				<dt>Their identity:</dt>
				<dd><a x-text="rkey" x-bind:href="'data:text/plain;charset=utf-8,' + rkey_armor" download="publickey.asc"></a></dd>
				<dt>Message number:</dt>
				<dd x-text="message_count"></dd>
				<dt>Your receipt:<dt>
				<dd><a x-bind:href="g_data_endpoint + '/' + rcpt" x-text="rcpt"></a></dd>
			</dl>
			<textarea cols=72 rows=10 x-model="content" >
			</textarea>
			<br/>
			<div x-show='defaultname'>
				<select @change='identify = true;'>
					<option value=0>Stay anonymous</option>
					<option value=1>Identify yourself</option>
				</select>
				<div x-show="identify">
					<input name="id_name" placeholder="name" x-model="realname" /> <input name="id_email" placeholder="email" x-model="realemail" />
				</div>
			</div>
			<div x-data="{
					ready: false,
					}"
				x-on:messagestatechange.window='ready = checkState(STATE["RTS"]);'
					>
				<button 
					x-bind:disabled='!ready' @click="r = await tryDispatch(content, realname, realemail); rcpt = r;">sign, encrypt and send</button>
			</div>
		</div>
		<div x-data="{
			rst: false,
		     }">
			<button x-show='key && !rst' @click='rst = true;'>Discard key</button>
			<button x-show='rst' @dblclick='rst = false; passphrase_status = "please create new key"; have_passphrase = false; key = !purgeLocalKey(); message_count = 0;'>Double click to confirm discard key</button>
		</div>
	</body>
</html>
