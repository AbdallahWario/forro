<html>
	<head>
		<script>
let g_remote_key = undefined;
let g_local_key = undefined;
let g_remote_key_id = '(none)';
let g_local_key_id = '(none)';
let g_data_endpoint = window.location.href;
let g_counter = undefined;
let g_current_message = undefined;
		</script>
		<script src="node_modules/openpgp/dist/openpgp.min.js"></script>
		<script src="node_modules/jssha/dist/sha256.js"></script>
		<script defer src="/node_modules/alpinejs/dist/cdn.min.js"></script>
		<script src="/key.js"></script>
		<script>

			// Thanks to:
			// https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
			function buf2hex(buffer) { // buffer is an ArrayBuffer
				  return [...new Uint8Array(buffer)]
				      .map(x => x.toString(16).padStart(2, '0'))
				      .join('');
			}
		
			function msg_identifier() {
				return 'msg' + g_counter;
			}

			async function loadSettings() {
				let rs = await fetch(window.location.href + '/settings.json', {
					method: 'GET',
				});
				if (!rs.ok) {
					stateChange('could not load settings');
					throw('could not load settings');
				}
				return await rs.json();
			}

			async function setUp(o) {
				let k = undefined;
				try {
					stateChange('attempt load local signing key');
					k = await getKey('deadbeef');
				} catch {
					stateChange('generate local signing key');
					k = await generatePGPKey('deadbeef');
				};

				g_local_key = k;
				g_local_key_id = k.getKeyID().toHex();

				stateChange('load settings');
				let settings = await loadSettings();
				if (settings.data_endpoint !== undefined) {
					stateChange('update data endpoint');
					g_data_endpoint = settings.data_endpoint;
				}

				stateChange('load counter');
				let c = localStorage.getItem('msg_count');
				if (c == null) {
					g_counter = 0;
				} else {
					g_counter = parseInt(c);
				}
				g_current_message = g_counter;

				stateChange('load remote encryption key');
				let r = await fetch(settings.remote_pubkey_url);
				let remote_key_src = await r.text();
				let remote_key = await openpgp.readKey({
					armoredKey: remote_key_src,
				});
				g_remote_key = remote_key;
				g_remote_key_id = g_remote_key.getKeyID().toHex();
				
				stateChange('ready to send');
			}

			async function stateChange(s) {
				const ev = new CustomEvent('messagestatechange', {
					bubbles: true,
					cancelable: false,
					composed: true,
					detail: {
						s: s,
						c: g_counter,
						kr: g_remote_key_id,
						kl: g_local_key_id,
					},
				});
				window.dispatchEvent(ev);
			}

			async function try_dispatch(s) {
				try {
					return await dispatch(s)
				} catch(e) {
					stateChange('send fail: ' + e);
					return 'failed';
					// on fail the msg count will be wrong in error message
				}
			}

			async function dispatch(s) {
				stateChange('encrypt message ' + g_counter);
				const sha_raw = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
				sha_raw.update(s);
				const digest = sha_raw.getHash("HEX");
				console.log('digest', digest);
				let msg = await openpgp.createMessage({
					text: s,
				});
				let enc = g_remote_key;
				let m = await openpgp.encrypt({
					encryptionKeys: enc,
					format: 'binary',
					message: msg,
				});
				let em = await openpgp.createMessage({
					binary: m,
				});
				//let emb = new TextEncoder("utf-8").encode(m);
				//const sha = new jsSHA("SHA-256", "UINT8ARRAY");
				let pfx = msg_identifier();
				//let pfx_b = new TextEncoder("utf-8").encode(pfx);
				//console.log('ppffx', pfx_b, m);
				//sha.update(pfx_b);
				//sha.update(identity);
				//const digest_enc = sha.getHash("HEX");

				stateChange('sign message ' + g_counter);
				let sig = await openpgp.sign({
					signingKeys: g_local_key,
					message: em,
					format: 'binary',
					detached: true,
				});

				stateChange('encode request for message ' + g_counter);
				let pubkey = g_local_key.toPublic().write();
				let pubkey_str = String.fromCharCode.apply(null, pubkey);
				let sig_str = String.fromCharCode.apply(null, sig);

				//let rcpt_unencrypted = buf2hex(digest);
				//let rcpt = buf2hex(digest_enc);
				//rcpt = digest_enc;
				console.debug('digest for unencrypted message:', digest);
				//console.debug('digest for encrypted message:', rcpt);

				sig_b = btoa(sig_str);
				pub_b = btoa(pubkey_str);

				stateChange('send message ' + g_counter);
				let res = await fetch(g_data_endpoint + '/' + pfx, {
					method: 'PUT',
					body: m,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG pgp:' + pub_b + ':' + sig_b,
					}
				});
				
				rcpt = res.text();
				stateChange('update local state, next message is: ' + g_counter);
				g_counter += 1;
				localStorage.setItem('msg_count', g_counter);
				g_current_message += 1;

				stateChange('ready to send next message');
				return rcpt;
			};

			window.addEventListener('messagestatechange', (v) => {
				console.debug('message state change:', v.detail.s);
			});

			//function toEndpointUrl(s) {
			//	let u = g_data_endpoint + '/' + s;
			//	return '<a href=\"' + u + '\">' + s + '</a>';
			//}

			function toEndpointUrl(s) {
				return s;
			}
		</script>
	</head>

	<body>
		<div x-init="await setUp(this);" x-data="{
			key: '(none)',
			rkey: '(none)',
			message_status: '(none)',
			message_count: g_counter,
			rcpt: ' ',
			content: '',
		
			}">
			<dl>
				<dt>Application:</dt>
				<dd>forro v0.0.1 (GPLv3)</dt>
				<dt>Status:</dt>
				<dd x-text="message_status" x-on:messagestatechange.window="message_status = $event.detail.s; message_count = $event.detail.c; key = $event.detail.kl, rkey = $event.detail.kr;"></dd>
				<dt>Your identity:</dt>
				<dd x-text="key"></dd>
				<dt>Their identity:</dt>
				<dd x-text="rkey"></dd>
				<dt>Message number:</dt>
				<dd x-text="message_count"></dd>
				<dt>Your receipt:<dt>
				<dd x-text="rcpt"></dd>
			</dl>
			<textarea cols=72 rows=10 x-model="content" >
			</textarea>
			<br/>
			<button @click="r = await try_dispatch(content); rcpt = 'message ' + g_current_message + ': ' + toEndpointUrl(r);">sign, encrypt and send</button>
		</div>
	</body>
</html>
