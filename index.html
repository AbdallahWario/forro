<html>
	<head>
		<script>
const PUBKEY_PFX  = 'pgp.publickey';
let g_passphrase = undefined;
let g_passphrase_use = true;
let g_passphrase_time = new Date(0);
let g_remote_key = undefined;
let g_local_key = undefined;
let g_remote_key_id = '(none)';
let g_local_key_id = '(none)';
let g_remote_key_name = '?';
let g_local_key_name = '?';
let g_local_key_identified = false;
let g_data_endpoint = window.location.href;
let g_counter = undefined;
		</script>
		<script src="node_modules/openpgp/dist/openpgp.min.js"></script>
		<script src="node_modules/jssha/dist/sha256.js"></script>
		<script defer src="node_modules/alpinejs/dist/cdn.min.js"></script>
		<script src="key.js"></script>
		<script src="name.js"></script>
		<script>

			// Thanks to:
			// https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
			function buf2hex(buffer) { // buffer is an ArrayBuffer
				  return [...new Uint8Array(buffer)]
				      .map(x => x.toString(16).padStart(2, '0'))
				      .join('');
			}
		
			function msg_identifier() {
				return 'msg' + g_counter;
			}

			async function loadSettings() {
				let rs = await fetch(window.location.href + '/settings.json', {
					method: 'GET',
				});
				if (!rs.ok) {
					stateChange('could not load settings');
					throw('could not load settings');
				}
				return await rs.json();
			}

			function getEffectiveName(k) {
				let kl = k.toPacketList();
				let klf = kl.filterByTag(openpgp.enums.packet.userID);
				if (klf.length > 1) {
					g_local_key_identified = true;
				}
				console.log('klf', klf[0]);
				return klf[klf.length-1].name;
			}
			
			async function unlockLocalKey(pwd) {
				try {
					stateChange('check existing key');
					g_local_key = await getKey(pwd);
				} catch(e) {
					return false;	
				}
				const decrypted = g_local_key.isDecrypted()
				stateChange('found key ' + g_local_key.getKeyID().toHex() + ' (decrypted: ' + decrypted + ')');
				return decrypted;
			}

			async function applyLocalKey() {
				g_local_key_id = g_local_key.getKeyID().toHex();
				g_local_key_name = getEffectiveName(g_local_key);
				
				stateChange('load counter');
				let c = localStorage.getItem('msg_count');
				if (c == null) {
					g_counter = 0;
				} else {
					g_counter = parseInt(c);
				}
				stateChange('ready to send');

			}

			async function setUp() {
				stateChange('load settings');
				let settings = await loadSettings();
				if (settings.data_endpoint !== undefined) {
					stateChange('update data endpoint to ' + settings.data_endpoint);
					g_data_endpoint = settings.data_endpoint;
				}

				let r = await fetch(settings.remote_pubkey_url);
				let remote_key_src = await r.text();
				let remote_key = await openpgp.readKey({
					armoredKey: remote_key_src,
				});
				g_remote_key = remote_key;
				g_remote_key_id = g_remote_key.getKeyID().toHex();
				g_remote_key.getPrimaryUser().then((v) => {
					g_remote_key_name = v.user.userID.name;
					stateChange('loaded remote encryption key');
				});
			}

			async function stateChange(s) {
				let k_remote_str = '';
				let k_local_str = '';
				if (g_remote_key !== undefined) {
					k_remote_str = g_remote_key_id + ' (' + g_remote_key_name + ')';
				}
				if (g_local_key !== undefined) {
					k_local_str = g_local_key_id + ' (' + g_local_key_name + ')';
				}

				const ev = new CustomEvent('messagestatechange', {
					bubbles: true,
					cancelable: false,
					composed: true,
					
					detail: {
						s: s,
						c: g_counter,
						kr: k_remote_str,
						kl: k_local_str,
					},
				});
				window.dispatchEvent(ev);
			}

			async function tryDispatch(s, name, email) {
				try {
					return await dispatch(s, name, email)
				} catch(e) {
					console.error(e);
					stateChange('send fail: ' + e);
					return 'failed';
					// on fail the msg count will be wrong in error message
				}
			}

			async function tryIdentify(name, email) {
				if (g_local_key_identified) {
					return false;
				}
				g_local_key = await identify(g_local_key, name, email, 'deadbeef');
				g_local_key_name = getEffectiveName(g_local_key);
				await stateChange('apply name change: ' + g_local_key_name);
				console.debug('updated public key', g_local_key.toPublic().armor());
				g_local_key_identified = true;
			}

			async function dispatch(s, name, email) {
				if (name) {
					if (!validateEmail(email)) {
						throw 'invalid email: ' + email;
					}
					await tryIdentify(name, email);
				}

				let pfx = msg_identifier();

				stateChange('sign and encrypt message ' + g_counter);
				const sha_raw = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
				sha_raw.update(s);
				const digest = sha_raw.getHash("HEX");
				console.debug('digest for unencrypted message:', digest);
	
				const rcpt_public = await generatePointer(g_local_key, PUBKEY_PFX + g_remote_key.getFingerprint());
				console.debug('digest for pubkey:', rcpt_public);

				const payload = "msg id: " + pfx + "\npubkey link: " + g_data_endpoint + "/" + rcpt_public + "\n\n" + s;
				const msg = await openpgp.createMessage({
					text: payload,
				});
				let msg_sig_inner = await openpgp.sign({
					signingKeys: g_local_key,
					message: msg,
					format: 'binary',
				});

				//let envelope = await openpgp.createMessage({
				//	text: g_local_key.toPublic().armor() + msg_sig_inner, //msg.armor() + sig_inner,
				//});

				const msg_sig = await openpgp.createMessage({
					binary: msg_sig_inner,
				});

				const enc = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_sig,
				});

				let envelope = await openpgp.createMessage({
					binary: enc,
				});
				
				stateChange('sign and encode message request ' + g_counter);
				const auth = await generateAuth(g_local_key, envelope);

				const rcpt = await generatePointer(g_local_key, pfx);
				console.debug('digest for encrypted message:', rcpt);

				stateChange('send message ' + g_counter);
				let res = await fetch(g_data_endpoint + '/' + pfx, {
					method: 'PUT',
					body: enc,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + auth,
					}
				});
				
				rcpt_remote = await res.text();
				if (rcpt_remote.toLowerCase() != rcpt.toLowerCase()) {
					throw "mutable ref mismatch between local and server; " + rcpt + " != " + rcpt_remote;
				}
				g_counter += 1;
				stateChange('update local state, next message is: ' + g_counter);
				localStorage.setItem('msg_count', g_counter);

				stateChange('sign and encode public key store request');
				const pubkey_bin = g_local_key.toPublic().write();
				const msg_pubkey = await openpgp.createMessage({
					binary: pubkey_bin,
				});

				const enc_pubkey = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_pubkey,
				});
				let envelope_pubkey = await openpgp.createMessage({
					binary: enc_pubkey,
				});

				const pubkey_auth = await generateAuth(g_local_key, envelope_pubkey);

				stateChange('send publickey ' + g_local_key_id);
				res = await fetch(g_data_endpoint + '/' + PUBKEY_PFX + g_remote_key.getFingerprint(), {
					method: 'PUT',
					body: enc_pubkey,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + pubkey_auth,
					}
				});


				stateChange('ready to send next message');
				return rcpt;
			};
		
			async function createLocalKey(pwd) {
				stateChange('generate new local signing key');
				const uid = {
					name: generateName(),
					email: 'foo@devnull.holbrook.no',
				};
				g_local_key = await generatePGPKey(pwd, uid);
				console.debug('you will initially be called', uid.name);
			}

			async function setPwd(pwd) {
				if (pwd === undefined) {
					if (g_local_key === undefined) {
						g_passphrase_use = false;
						await createLocalKey();
					}
				} else if (pwd.length == 0) {
					return false;
				} else if (g_local_key === undefined) {
					await createLocalKey(pwd);
				}
				const  r = await unlockLocalKey(pwd);
				if (r) {
					applyLocalKey();
				}
				return r;
			}

			window.addEventListener('messagestatechange', (v) => {
				console.debug('message state change:', v.detail.s);
			});



		</script>
	</head>

	<body x-data="{
		have_passphrase: false,
		key: '',
		rkey: '',
		key_armor: undefined,
		rkey_armor: undefined,
		defaultname: true,
		identify: false,
		realname: '',
		realemail: '',
		message_status: '',
		message_count: g_counter,

		}"
>
		<h1><a href="https://git.defalsify.org/cgit/forro">forro v0.0.4 (GPLv3)</a></h1>
		
		<div x-data="{
			passphrase_cache: '',
			passphrase_status: 'please create key',
		     }"
		     
		      x-init="
		      have_passphrase = await unlockLocalKey();
		      if (key.length > 0) {
				if (have_passphrase) {
					applyLocalKey();
				} else {
					passphrase_status = 'please unlock key';
				}
			}"

			x-show='!have_passphrase'>
			<input name="pwd" type="password" x-model='passphrase_cache' x-bind:placeholder='passphrase_status' />
			<button @click='have_passphrase = true; await setPwd(passphrase_cache);' >go</button>
			<button x-show='!key' @click='have_passphrase = true; await setPwd();' >without passphrase</button>
		</div>
		<div x-show='have_passphrase' x-init="await setUp();" x-data="{
			rcpt: '',
			content: '',
			
			}">
			<dl>
				<dt>Status:</dt>
				<dd x-text="message_status" x-on:messagestatechange.window="message_status = $event.detail.s; message_count = $event.detail.c; key = $event.detail.kl; rkey = $event.detail.kr; if (key_armor === undefined && g_local_key !== undefined) { key_armor = g_local_key.armor(); }; if (rkey_armor === undefined && g_remote_key !== undefined) { rkey_armor = g_remote_key.armor(); }; defaultname = !g_local_key_identified;"></dd>

				<dt>Your identity:</dt>
				<dd><a x-text="key" x-bind:href="'data:text/plain;charset=utf-8,' + key_armor" download="privatekey.asc"></a></dd>
				<dt>Their identity:</dt>
				<dd><a x-text="rkey" x-bind:href="'data:text/plain;charset=utf-8,' + rkey_armor" download="publickey.asc"></a></dd>
				<dt>Message number:</dt>
				<dd x-text="message_count"></dd>
				<dt>Your receipt:<dt>
				<dd><a x-bind:href="g_data_endpoint + '/' + rcpt" x-text="rcpt"></a></dd>
			</dl>
			<textarea cols=72 rows=10 x-model="content" >
			</textarea>
			<br/>
			<div x-show='defaultname'>
				<select @change='identify = true;'>
					<option value=0>Stay anonymous</option>
					<option value=1>Identify yourself</option>
				</select>
				<div x-show="identify">
					<input name="id_name" placeholder="name" x-model="realname" /> <input name="id_email" placeholder="email" x-model="realemail" />
				</div>
			</div>
			<div>
				<button @click="r = await tryDispatch(content, realname, realemail); rcpt = r;">sign, encrypt and send</button>
			</div>
		</div>
	</body>
</html>
