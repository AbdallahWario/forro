<html>
	<head>
		<script>
const PUBKEY_PFX  = 'pgp.publickey';
const STATE = {
	DEV: 1 << 0,
	PANIC: 1 << 1,
	RTS:  1 << 2,
	SEND_ERROR: 1 << 3,
	SETTINGS: 1 << 4,
	REMOTE_KEY: 1 << 5,
	LOCAL_KEY: 1 << 6,
	LOCAL_KEY_DECRYPTED: 1 << 7,
	LOCAL_KEY_IDENTIFIED: 1 << 8,
	LOCAL_KEY_GENERATE: 1 << 9,
	PASSPHRASE_ACTIVE: 1 << 10,
	PASSPHRASE_FAIL: 1 << 11,
	ACK_MESSAGE: 1 << 12,
	ACK_PUBKEY: 1 << 13,
	HELP: 1 << 14,
};
const STATE_KEYS = Object.keys(STATE);

let g_passphrase = undefined;
let g_passphrase_use = true;
let g_passphrase_time = 0;
let g_remote_key = undefined;
let g_local_key = undefined;
let g_remote_key_id = '(none)';
let g_remote_key_name = '?';
let g_local_key_id = '(none)';
let g_local_key_name = '?';
let g_local_key_identified = false;
let g_data_endpoint = window.location.href;
let g_state = 0;
let g_helpstate = 0;
let g_counter = undefined;

		</script>
		<script src="node_modules/openpgp/dist/openpgp.min.js"></script>
		<script src="node_modules/jssha/dist/sha256.js"></script>
		<script defer src="node_modules/alpinejs/dist/cdn.min.js"></script>
		<script src="key.js"></script>
		<script src="name.js"></script>
		<script src="help.js"></script>
		<script>

			// Thanks to:
			// https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
			function buf2hex(buffer) { // buffer is an ArrayBuffer
				  return [...new Uint8Array(buffer)]
				      .map(x => x.toString(16).padStart(2, '0'))
				      .join('');
			}
		
			function msg_identifier() {
				return 'msg' + g_counter;
			}

			function debugState(state) {
				let s = '';
				for (let i = 0; i < STATE_KEYS.length; i++) {
					const v = 1 << i;
					if (checkState(state, v)) {
						const k = STATE_KEYS[i];
						if (s.length > 0) {
							s += ', ';
						}
						s += k;
					}
				}
				return s;
			};
			
			function checkState(bit_check, bit_field) {
				if (bit_field != 0 && !bit_field) {
					bit_field = g_state;
				}
				return (bit_check & bit_field) > 0;
			};

			async function loadSettings() {
				let rs = await fetch(window.location.href + '/settings.json', {
					method: 'GET',
				});
				if (!rs.ok) {
					stateChange('could not load settings');
					throw('could not load settings');
				}
				return await rs.json();
			}

			function getEffectiveName(k) {
				let kl = k.toPacketList();
				let klf = kl.filterByTag(openpgp.enums.packet.userID);
				if (klf.length > 1) {
					stateChange('local key has been identified', STATE["LOCAL_KEY_IDENTIFIED"]);
					g_local_key_identified = true;
				}
				return klf[klf.length-1].name;
			}
			
			async function unlockLocalKey(pwd) {
				let state = [];
				try {
					g_local_key = await getKey(pwd);
					state.push(STATE['LOCAL_KEY']);
				} catch(e) {
					console.error(e);
					stateChange('could not unlock key (passphrase: ' + pwd !== undefined + ')');
					return false;
				}
				const decrypted = g_local_key.isDecrypted()
				if (decrypted) {
					state.push(STATE['LOCAL_KEY_DECRYPTED']);
				}

				stateChange('found key ' + g_local_key.getKeyID().toHex() + ' (decrypted: ' + decrypted + ')', state);
				return decrypted;
			}

			async function applyLocalKey() {
				g_local_key_id = g_local_key.getKeyID().toHex();
				g_local_key_name = getEffectiveName(g_local_key);
				
				stateChange('load counter');
				let c = localStorage.getItem('msg-count');
				if (c == null) {
					g_counter = 0;
				} else {
					g_counter = parseInt(c);
				}
				stateChange('ready to send', STATE['RTS']);
			}

			async function setUp() {
				let settings = await loadSettings();
				if (settings.dev) {
					stateChange("devmode on", STATE.DEV);
				}
				if (settings.help) {
					stateChange("helpmode on", STATE.HELP);
				}

				if (settings.data_endpoint !== undefined) {
					g_data_endpoint = settings.data_endpoint;
					stateChange('updated data endpoint to ' + settings.data_endpoint);
				}

				stateChange('loaded settings', STATE['SETTINGS']);
				let r = await fetch(settings.remote_pubkey_url);
				let remote_key_src = await r.text();
				let remote_key = await openpgp.readKey({
					armoredKey: remote_key_src,
				});
				g_remote_key = remote_key;
				g_remote_key_id = g_remote_key.getKeyID().toHex();
				g_remote_key.getPrimaryUser().then((v) => {
					g_remote_key_name = v.user.userID.name;
					stateChange('loaded remote encryption key', STATE['REMOTE_KEY']);
				});
			}

			async function stateChange(s, set_states, rst_states) {
				if (!set_states) {
					set_states = [];
				} else if (!Array.isArray(set_states)) {
					set_states = [set_states];
				}
				if (!rst_states) {
					rst_states = [];
				} else if (!Array.isArray(rst_states)) {
					rst_states = [rst_states];
				}
				let new_state = g_state;
				for (let i = 0; i < set_states.length; i++) {
					let state = parseInt(set_states[i]);
					new_state |= state;
				}
				for (let i = 0; i < rst_states.length; i++) {
					let state = parseInt(set_states[i]);
					new_state = new_state & (0xffffffff & ~rst_states[i]);
				}
				g_state = new_state;

				const ev = new CustomEvent('messagestatechange', {
					bubbles: true,
					cancelable: false,
					composed: true,
					detail: {
						s: s,
						c: g_counter,
						kr: g_remote_key_id,
						nr: g_remote_key_name,
						kl: g_local_key_id,
						nl: g_local_key_name,
						state: new_state,
					},
				});
				window.dispatchEvent(ev);
			}

			async function tryDispatch(s, name, email) {
				stateChange('starting dispatch', undefined, [STATE['RTS'], STATE['SEND_ERROR']]);
				let r = undefined;
				try {
					r = await dispatch(s, name, email)
				} catch(e) {
					console.error(e);
					stateChange('send fail: ' + e, STATE['SEND_ERROR']);
					r = 'failed';
					// on fail the msg count will be wrong in error message
				}
				stateChange('ready to send again', STATE['RTS']);
				return r;
			}

			function getPassphrase() {
				return g_passphrase;
			}

			async function tryIdentify(name, email) {
				if (g_local_key_identified) {
					return false;
				}
				g_local_key = await identify(g_local_key, name, email, getPassphrase());
				g_local_key_name = getEffectiveName(g_local_key);
				await stateChange('apply name change: ' + g_local_key_name);
				console.debug('updated public key', g_local_key.toPublic().armor());
				g_local_key_identified = true;
			}

			async function dispatch(s, name, email) {
				if (name) {
					if (!validateEmail(email)) {
						throw 'invalid email: ' + email;
					}
					await tryIdentify(name, email);
				}

				let pfx = msg_identifier();

				stateChange('sign and encrypt message ' + g_counter);
				const sha_raw = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
				sha_raw.update(s);
				const digest = sha_raw.getHash("HEX");
				console.debug('digest for unencrypted message:', digest);
	
				const rcpt_public = await generatePointer(g_local_key, PUBKEY_PFX + g_remote_key.getFingerprint());
				console.debug('digest for pubkey:', rcpt_public);

				const payload = "msg id: " + pfx + "\npubkey link: " + g_data_endpoint + "/" + rcpt_public + "\n\n" + s;
				const msg = await openpgp.createMessage({
					text: payload,
				});
				let msg_sig_inner = await openpgp.sign({
					signingKeys: g_local_key,
					message: msg,
					format: 'binary',
				});

				const msg_sig = await openpgp.createMessage({
					binary: msg_sig_inner,
				});

				let r_enc = await encryptMessage(msg_sig, pfx);
				let rcpt = await dispatchToEndpoint(r_enc, pfx);

				stateChange(rcpt, STATE['ACK_MESSAGE']);
				stateChange('message submit complete', undefined, STATE['ACK_MESSAGE']);
				g_counter += 1;

				localStorage.setItem('msg-count', g_counter);
				stateChange('update local state, next message is: ' + g_counter);

				const r_enc_pub = await encryptPublicKey(g_local_key);
				let rcpt_pubkey = await dispatchToEndpoint(r_enc_pub, PUBKEY_PFX + g_remote_key.getFingerprint());
//
//				res = await fetch(g_data_endpoint + '/' + PUBKEY_PFX + g_remote_key.getFingerprint(), {
//					method: 'PUT',
//					body: enc_pubkey,
//					headers: {
//						'Content-Type': 'application/octet-stream',
//						'Authorization': 'PUBSIG ' + pubkey_auth,
//					}
//				});

//				rcpt_pubkey = await res.text();
				stateChange(rcpt_pubkey, STATE['ACK_PUBKEY']);
				stateChange('publickey submit complete', undefined, STATE['ACK_PUBKEY']);
				return rcpt;
			}

			async function encryptPublicKey(k) {
				const pubkey_bin = g_local_key.toPublic().write();
				const msg_pubkey = await openpgp.createMessage({
					binary: pubkey_bin,
				});

				const enc_pubkey = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_pubkey,
				});
				let envelope_pubkey = await openpgp.createMessage({
					binary: enc_pubkey,
				});

				const auth = await generateAuth(g_local_key, envelope_pubkey);

				return {
					msg: enc_pubkey,
					auth: auth,
					rcpt: null,
				};
			}

			async function dispatchToEndpoint(o, pfx) {
				let res = await fetch(g_data_endpoint + '/' + pfx, {
					method: 'PUT',
					body: o.msg,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + o.auth,
					}
				});
		
				rcpt_remote = await res.text();

				if (o.rcpt) {
					if (rcpt_remote.toLowerCase() != o.rcpt.toLowerCase()) {
						throw "mutable ref mismatch between local and server; " + o.rcpt + " != " + rcpt_remote;
					}
				} else {
					console.warn('have no digest to check server reply against');
				}
				return rcpt_remote;
			}

			async function encryptMessage(msg, pfx) {
				const enckey_local = await g_local_key.getEncryptionKey();
				const enckey_remote = await g_remote_key.getEncryptionKey();

				const enc = await openpgp.encrypt({
					encryptionKeys: [g_remote_key, g_local_key],
					format: 'binary',
					message: msg,
				});
				
				console.debug('encrypted for keys', enckey_local.getKeyID().toHex(), enckey_remote.getKeyID().toHex());
				let envelope = await openpgp.createMessage({
					binary: enc,
				});
				
				stateChange('sign and encode message request ' + g_counter);
				const auth = await generateAuth(g_local_key, envelope);

				const rcpt = await generatePointer(g_local_key, pfx);
				console.debug('digest for encrypted message:', rcpt);
				
				return {
					msg: enc,
					rcpt: rcpt,
					auth: auth,
				};
			}
		
			async function createLocalKey(pwd) {
				stateChange('generate new local signing key', STATE["LOCAL_KEY_GENERATE"]);
				const uid = {
					name: generateName(),
					email: 'foo@devnull.holbrook.no',
				};
				g_local_key = await generatePGPKey(pwd, uid);
				stateChange('new local signing key named ' + uid.name, STATE["LOCAL_KEY"], STATE["LOCAL_KEY_GENERATE"]);
			}

			async function setPwd(pwd) {
				stateChange('attempt password set', undefined, STATE['PASSPHRASE_FAIL']);
				if (!pwd) {
					pwd = undefined;
				}
				if (pwd === undefined) {
					if (g_local_key === undefined) {
						g_passphrase_use = false;
						await createLocalKey();
					}
				} else if (g_local_key === undefined) {
					await createLocalKey(pwd);
				}
				let r = await unlockLocalKey(pwd);
				if (!r) {
					stateChange('key unlock fail', STATE['PASSPHRASE_FAIL']);
					return false;
				}
				if (pwd !== undefined) {
					stateChange('passphrase validated', STATE['PASSPHRASE_ACTIVE']);
				}
				applyLocalKey();
				g_passphrase = pwd;
				g_passphrase_time = Date.now();
				return r;
			}

			function purgeLocalKey() {
				key_id = g_local_key_id;
				localStorage.removeItem('pgp-key');
				localStorage.removeItem('msg-count');
				g_local_key = undefined;
				g_local_key_id = undefined;
				g_local_key_identified = false;
				g_counter = 0;
				g_passphrase = undefined;
				g_passphrase_time = new Date(0);
				const purgeResetStates =  [
					STATE["LOCAL_KEY"],
					STATE["LOCAL_KEY_DECRYPTED"],
					STATE["LOCAL_KEY_IDENTIFIED"],
					STATE["PASSPHRASE_STORED"],
					STATE["RTS"],
					STATE["SEND_ERROR"],
				];
				stateChange('deleted local key ' + key_id, undefined, purgeResetStates);
				return true;
			}

			async function tryHelpFor(...k) {
				//if (!checkState(STATE.HELP)) {
				//	return;
				//}
				const r = await helpFor(g_helpstate, g_state, k);
				g_helpstate = r.state;
				const ev = new CustomEvent('help', {
					bubbles: true,
					cancelable: false,
					composed: true,
					detail: {
						v: r.v,
					},
				});
				window.dispatchEvent(ev);
			}

			window.addEventListener('messagestatechange', (v) => {
				console.debug('message state change:', v.detail.state, debugState(v.detail.state), v.detail.s);
			});



		</script>
		<style type="text/css">
div#helpdiv .old {
	color: #aaa;
}
h1 {
	margin-block-end: 1em;
	margin-block-start: 0.5em;
	font-size: 2em;
}
		</style>
	</head>

	<body x-data="{
		unlock_set: false,
		message_status: '',
		message_count: g_counter,
		last_state: 0,

		get haveSettings() {
			return this.last_state & STATE['SETTINGS'] > 0;
		},

		get isDev() {
			return checkState(this.last_state, STATE.DEV);
		},

		get isHelp() {
			return checkState(this.last_state, STATE.HELP);
		},

		get lastState() {
			return debugState(this.last_state);
		},

		get haveKey() {
			return checkState(this.last_state, STATE['LOCAL_KEY']);
		},

		get unlockedKey() {
			return checkState(this.last_state, STATE['LOCAL_KEY_DECRYPTED']);
		},

		get haveRemoteKey() {
			return checkState(this.last_state, STATE['REMOTE_KEY']);
		},

		}"

		      x-init="unlockLocalKey();"

		      @messagestatechange.window='
				message_status = $event.detail.s;
				message_count = $event.detail.c;
			      last_state = $event.detail.state;
				if (!unlock_set && checkState(STATE["LOCAL_KEY_DECRYPTED"])) {
		      			unlock_set = true;
					$dispatch("unlocked");
			      }
			      if (checkState(STATE["PASSPHRASE_FAIL"])) {
					$dispatch("passfail");
				}
				if (checkState(STATE["ACK_MESSAGE"])) {
				      $dispatch("rcpt", {v: $event.detail.s});
				}
				'

		      @unlocked='applyLocalKey();'

		      @rst.window='unlock_set = false; message_count = 0'

		      >

		      <h1><a href="https://git.defalsify.org/cgit/forro">forro v0.0.5 (GPLv3)</a></h1>
		      
		<div id="app"> 
			<div id="helpdiv" style="height: 6em;"
					  x-show="isHelp"
					  >
			      <hr/>
				<template x-data="{
					help_cap: 128, // if set to 0 then no buffer
					help_display_count: 5, // if help_cap is 0, ignore
					help_contents: [],
					help_lastcount: 0,
					help_count: 0,
					help_crsr: -1,

					addHelpContents(v) {
						if (this.help_cap == 0) {
							this.help_display_count = v.length;
							this.help_count = v.length;
							this.help_contents = v;
							this.help_crsr = this.help_count - 1;
						} else {
							for (let i = 0; i < v.length; i++) {
								this.help_crsr += 1;
								this.help_crsr %= this.help_cap;
								this.help_contents[this.help_crsr] = v[i];
								if (this.help_count < this.help_cap) {
									this.help_count += 1;
								}
							}
						}
						if (v.length > 0) {
							this.help_lastcount = v.length;
						}
					},

					get helpContents() {
						if (this.help_crsr < 0) {
							return [];
						}
						let contents = [];

						let l = this.help_display_count;
						if (l > this.help_count) {
							l = this.help_count;
						}


						let c = (this.help_crsr - l + 1);
						if (c < 0) {
							c = l + c;
						}
						
						new_threshold = l - this.help_lastcount;
						for (let i = 0; i < l; i++) {
							if (this.help_cap > 0) {
								c %= this.help_cap;
							}
							is_old = i < new_threshold;
							v = [this.help_contents[c], is_old ? 'old' : 'new'];
							contents.push(v); //this.help_contents[c]);
							c += 1;
						}
						return contents;
					},
					}"
					x-init="tryHelpFor('welcome');"
					x-for="(v) in helpContents"
					@help.window="addHelpContents($event.detail.v);">
					<p style="font-size: 0.8em; line-height: 0.3em;" x-html="v[0]" :class="v[1]" />
				</template>
			</div>
		<hr/>
		<div id="localkey" x-data="{
			passphrase_cache: '',
			passphrase_status: '',
			passphrase_default_status: 'create key with passphrase',
			get passphraseStatus() {
				return this.passphrase_status ? this.passphrase_status : this.passphrase_default_status;
			},
		     }"
		     
		      

			x-show='!unlockedKey'
			>
			<input name="pwd" type="password"
				x-model='passphrase_cache'
				x-bind:placeholder='passphraseStatus'
				@passfail.window='passphrase_status = "wrong_passphrase"; passphrase_cache = "";';
				@messagestatechange.window='if (checkState(STATE["LOCAL_KEY"])) { passphrase_default_status = "please unlock key"; };'
				@rst.window='passphrase_status = "please create new key";' 
					  >
			<button x-data="{
					go_label: 'go',
				}"

				x-text='go_label'

				@passfail.window='go_label = "go again";'
				@rst.window='go_label = "go";'

				@click='setPwd(passphrase_cache);'
				></button>
				

			<button x-show='!haveKey' @click='tryHelpFor("nopass"); setPwd();' setPwd();' >without passphrase</button>
		</div>
		<div id="message_panel"
			x-show='unlockedKey'
			x-init='setUp();'
			x-data="{
				rcpt: '',
				content: '',
				key: '',
				rkey: '',
				key_name: '',
				rkey_name: '',
				defaultname: true,
				key_content: '',
				rkey_content: '',
				get localKeyArmor() {
					return 'data:text/plain;charset=utf8,' + this.key_content;
				},
				get localKeyFilename() {
					return 'privatekey_' + this.key + '.asc';
				},
				get remoteKeyArmor() {
					return 'data:text/plain;charset=utf8,' + this.rkey_content;
				},
				get remoteKeyFilename() {
					return 'publickey_' + this.rkey + '.asc';
				},
				get keyDisplay() {
					if (!this.key) {
						return '';
					}
					return this.key + ' (' + this.key_name + ')';
				},
				get rkeyDisplay() {
					if (!this.rkey) {
						return '';
					}
					return this.rkey + ' (' + this.rkey_name + ')';
				},
				}"
			@rcpt.window='rcpt = $event.detail.v;'
			@messagestatechange.window='
				key = $event.detail.kl;
				rkey = $event.detail.kr; 
				key_name = $event.detail.nl;
				rkey_name = $event.detail.nr;

				if (checkState(STATE["LOCAL_KEY"])) {
				      if (key_content == "") {
					key_content = g_local_key.armor();
				      }
				}
				if (checkState(STATE["REMOTE_KEY"])) {
				      if (rkey_content == "") {
					rkey_content = g_remote_key.armor();
				      }
				}
			'
		       >
			<dl>
				<dt>Status:</dt>
				<dd x-text="message_status" x-on:messagestatechange.window="defaultname = !g_local_key_identified;"></dd>

				<dt>Your identity:</dt>
				<dd><a x-text="keyDisplay" title="Click to download your private key" x-bind:href="localKeyArmor" x-bind:download="localKeyFilename"></a></dd>
				<dt>Their identity:</dt>
				<dd><a x-text="rkeyDisplay" title="Click to download the recipient's public key" x-bind:href="remoteKeyArmor" x-bind:download="remoteKeyFilename"></a></dd>
				<dt>Message number:</dt>
				<dd x-text="message_count"></dd>
				<dt>Your receipt:<dt>
				<dd><a x-bind:href="g_data_endpoint + '/' + rcpt" x-text="rcpt"></a></dd>
			</dl>
			<textarea cols=72 rows=10 x-model="content" @focus="tryHelpFor('writemsg');">
			</textarea>
			<br/>
			<div x-data='{ 
				realname: "",
				realemail: "",
					    }'>
				<div x-show='defaultname'
				     x-data='{
					identify: false,
				     }'
				     @rst.window='identify = false;'
				     >
				     <select id="identity_select" @change='identify = $event.target.value > 0; if (identify) { tryHelpFor("identify") };'
						@rst.window='document.getElementById("identity_select").value=0;'>
						<option value=0 defaultselected>Stay anonymous</option>
						<option value=1>Identify yourself</option>
					</select>
					<div x-show="identify">
						<input name="id_name" placeholder="name" x-model="realname" /> <input name="id_email" placeholder="email" x-model="realemail" />
					</div>
				</div>
				<div x-data="{
						ready: false,
						}"
					x-on:messagestatechange.window='ready = checkState(STATE["RTS"]);'
						>
					<button 
						x-bind:disabled='!ready'
						@click="tryDispatch(content, realname, realemail);">sign, encrypt and send</button>
				</div>
			</div>
		</div>
		<div id="reset"
			x-data="{
			rst: false,
		     }">
			<button x-show='haveKey && !rst' @click='rst = true;'>Discard key</button>
			<button x-show='rst' @dblclick='rst = false; $dispatch("rst"); purgeLocalKey();'>Double click to confirm discard key</button>
		</div>

		<div id="dev" x-show='isDev'>
		<hr/>
		<h2>Devmode details</h2>
			<dl>
				<dt>last event</dt>
				<dd x-text='message_status' />
				<dt>state value</dt>
				<dd x-text='last_state' />
				<dt>state description</dt>
				<dd x-text='lastState' />
			</dl>
		</div>
	</body>
</html>
