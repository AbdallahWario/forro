<html>
	<head>
		<script>
const PUBKEY_PFX  = 'pgp.publickey';

let g_remote_key = undefined;
let g_local_key = undefined;
let g_remote_key_id = '(none)';
let g_local_key_id = '(none)';
let g_remote_key_name = '?';
let g_local_key_name = '?';
let g_data_endpoint = window.location.href;
let g_counter = undefined;
		</script>
		<script src="node_modules/openpgp/dist/openpgp.min.js"></script>
		<script src="node_modules/jssha/dist/sha256.js"></script>
		<script defer src="node_modules/alpinejs/dist/cdn.min.js"></script>
		<script src="key.js"></script>
		<script src="name.js"></script>
		<script>

			// Thanks to:
			// https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
			function buf2hex(buffer) { // buffer is an ArrayBuffer
				  return [...new Uint8Array(buffer)]
				      .map(x => x.toString(16).padStart(2, '0'))
				      .join('');
			}
		
			function msg_identifier() {
				return 'msg' + g_counter;
			}

			async function loadSettings() {
				let rs = await fetch(window.location.href + '/settings.json', {
					method: 'GET',
				});
				if (!rs.ok) {
					stateChange('could not load settings');
					throw('could not load settings');
				}
				return await rs.json();
			}

			async function setUp() {
				let k = undefined;
				try {
					stateChange('attempt load local signing key');
					k = await getKey('deadbeef');
				} catch {
					stateChange('generate initial bogus name');
					let name = generateName();
					let uid = {
						'name': name,
						'email': 'test@devnull.holbrook.no',
					};
					console.debug('you will initially be called', uid.name);

					stateChange('generate new local signing key');
					k = await generatePGPKey('deadbeef', uid);
				};

				g_local_key = k;
				g_local_key_id = k.getKeyID().toHex();

				let kl = k.toPacketList();
				let klf = kl.filterByTag(openpgp.enums.packet.userID);
				g_local_key_name = klf[klf.length-1].name;


				stateChange('load settings');
				let settings = await loadSettings();
				if (settings.data_endpoint !== undefined) {
					stateChange('update data endpoint to ' + settings.data_endpoint);
					g_data_endpoint = settings.data_endpoint;
				}

				stateChange('load counter');
				let c = localStorage.getItem('msg_count');
				if (c == null) {
					g_counter = 0;
				} else {
					g_counter = parseInt(c);
				}

				stateChange('load remote encryption key');
				let r = await fetch(settings.remote_pubkey_url);
				let remote_key_src = await r.text();
				let remote_key = await openpgp.readKey({
					armoredKey: remote_key_src,
				});
				g_remote_key = remote_key;
				g_remote_key_id = g_remote_key.getKeyID().toHex();
				g_remote_key.getPrimaryUser().then((v) => {
					g_remote_key_name = v.user.userID.name;
					stateChange('ready to send');
				});
			}

			async function stateChange(s) {
				const ev = new CustomEvent('messagestatechange', {
					bubbles: true,
					cancelable: false,
					composed: true,
					detail: {
						s: s,
						c: g_counter,
						kr: g_remote_key_id + ' (' + g_remote_key_name + ')',
						kl: g_local_key_id + ' (' + g_local_key_name + ')',
					},
				});
				window.dispatchEvent(ev);
			}

			async function try_dispatch(s) {
				try {
					return await dispatch(s)
				} catch(e) {
					console.error(e);
					stateChange('send fail: ' + e);
					return 'failed';
					// on fail the msg count will be wrong in error message
				}
			}

			async function dispatch(s) {
				let pfx = msg_identifier();

				stateChange('sign and encrypt message ' + g_counter);
				const sha_raw = new jsSHA("SHA-256", "TEXT", { encoding: "UTF8" });
				sha_raw.update(s);
				const digest = sha_raw.getHash("HEX");
				console.debug('digest for unencrypted message:', digest);
	
				const rcpt_public = await generatePointer(g_local_key, PUBKEY_PFX + g_remote_key.getFingerprint());
				console.debug('digest for pubkey:', rcpt_public);

				const payload = "msg id: " + pfx + "\npubkey link: " + g_data_endpoint + "/" + rcpt_public + "\n\n" + s;
				const msg = await openpgp.createMessage({
					text: payload,
				});
				let msg_sig_inner = await openpgp.sign({
					signingKeys: g_local_key,
					message: msg,
					format: 'binary',
				});

				//let envelope = await openpgp.createMessage({
				//	text: g_local_key.toPublic().armor() + msg_sig_inner, //msg.armor() + sig_inner,
				//});

				const msg_sig = await openpgp.createMessage({
					binary: msg_sig_inner,
				});

				const enc = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_sig,
				});

				let envelope = await openpgp.createMessage({
					binary: enc,
				});
				
				stateChange('sign and encode message request ' + g_counter);
				const auth = await generateAuth(g_local_key, envelope);

				const rcpt = await generatePointer(g_local_key, pfx);
				console.debug('digest for encrypted message:', rcpt);

				stateChange('send message ' + g_counter);
				let res = await fetch(g_data_endpoint + '/' + pfx, {
					method: 'PUT',
					body: enc,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + auth,
					}
				});
				
				rcpt_remote = await res.text();
				if (rcpt_remote.toLowerCase() != rcpt.toLowerCase()) {
					throw "mutable ref mismatch between local and server; " + rcpt + " != " + rcpt_remote;
				}
				g_counter += 1;
				stateChange('update local state, next message is: ' + g_counter);
				localStorage.setItem('msg_count', g_counter);

				stateChange('sign and encode public key store request');
				const pubkey_bin = g_local_key.toPublic().write();
				const msg_pubkey = await openpgp.createMessage({
					binary: pubkey_bin,
				});

				const enc_pubkey = await openpgp.encrypt({
					encryptionKeys: g_remote_key,
					format: 'binary',
					message: msg_pubkey,
				});
				let envelope_pubkey = await openpgp.createMessage({
					binary: enc_pubkey,
				});

				const pubkey_auth = await generateAuth(g_local_key, envelope_pubkey);

				stateChange('send publickey ' + g_local_key_id);
				res = await fetch(g_data_endpoint + '/' + PUBKEY_PFX + g_remote_key.getFingerprint(), {
					method: 'PUT',
					body: enc_pubkey,
					headers: {
						'Content-Type': 'application/octet-stream',
						'Authorization': 'PUBSIG ' + pubkey_auth,
					}
				});


				stateChange('ready to send next message');
				return rcpt;
			};

			window.addEventListener('messagestatechange', (v) => {
				console.debug('message state change:', v.detail.s);
			});

		</script>
	</head>

	<body>
		<div x-init="await setUp();" x-data="{
			key: '(none)',
			rkey: '(none)',
			message_status: '(none)',
			message_count: g_counter,
			rcpt: '',
			content: '',
			key_armor: undefined,
			rkey_armor: undefined,

			}">
			<dl>
				<dt>Application:</dt>
				<dd><a href="https://git.defalsify.org/cgit/forro">forro v0.0.2 (GPLv3)</a></dt>
				<dt>Status:</dt>
				<dd x-text="message_status" x-on:messagestatechange.window="message_status = $event.detail.s; message_count = $event.detail.c; key = $event.detail.kl; rkey = $event.detail.kr; if (key_armor === undefined && g_local_key !== undefined) { key_armor = g_local_key.armor(); }; if (rkey_armor === undefined && g_remote_key !== undefined) { rkey_armor = g_remote_key.armor(); };"></dd>
				<dt>Your identity:</dt>
				<dd><a x-text="key" x-bind:href="'data:text/plain;charset=utf-8,' + key_armor" download="privatekey.asc"></a></dd>
				<dt>Their identity:</dt>
				<dd><a x-text="rkey" x-bind:href="'data:text/plain;charset=utf-8,' + rkey_armor" download="publickey.asc"></a></dd>
				<dt>Message number:</dt>
				<dd x-text="message_count"></dd>
				<dt>Your receipt:<dt>
				<dd><a x-bind:href="g_data_endpoint + '/' + rcpt" x-text="rcpt"></a></dd>
			</dl>
			<textarea cols=72 rows=10 x-model="content" >
			</textarea>
			<br/>
			<button @click="r = await try_dispatch(content); rcpt = r;">sign, encrypt and send</button>
		</div>
	</body>
</html>
